<html><head><title>Cats: Const</title><meta charset="utf-8" /><meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" /><meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="author" content="Cats contributors" /><meta name="description" content="Lightweight, modular, and extensible library for functional programming" /><meta name="og:image" content="/cats/img/poster.png" /><meta name="og:title" content="Cats: Const" /><meta name="og:site_name" content="Cats" /><meta name="og:url" content="http://typelevel.org/cats/" /><meta name="og:type" content="website" /><meta name="og:description" content="Lightweight, modular, and extensible library for functional programming" /><link rel="icon" type="image/png" href="/cats/img/favicon.png" /><meta name="twitter:title" content="Cats: Const" /><meta name="twitter:image" content="http://typelevel.org/cats/img/poster.png" /><meta name="twitter:description" content="Lightweight, modular, and extensible library for functional programming" /><meta name="twitter:card" content="summary_large_image" /><link rel="icon" type="image/png" sizes="16x16" href="/cats/img/favicon16x16.png" /><link rel="icon" type="image/png" sizes="24x24" href="/cats/img/favicon24x24.png" /><link rel="icon" type="image/png" sizes="32x32" href="/cats/img/favicon32x32.png" /><link rel="icon" type="image/png" sizes="48x48" href="/cats/img/favicon48x48.png" /><link rel="icon" type="image/png" sizes="57x57" href="/cats/img/favicon57x57.png" /><link rel="icon" type="image/png" sizes="60x60" href="/cats/img/favicon60x60.png" /><link rel="icon" type="image/png" sizes="64x64" href="/cats/img/favicon64x64.png" /><link rel="icon" type="image/png" sizes="70x70" href="/cats/img/favicon70x70.png" /><link rel="icon" type="image/png" sizes="72x72" href="/cats/img/favicon72x72.png" /><link rel="icon" type="image/png" sizes="76x76" href="/cats/img/favicon76x76.png" /><link rel="icon" type="image/png" sizes="96x96" href="/cats/img/favicon96x96.png" /><link rel="icon" type="image/png" sizes="114x114" href="/cats/img/favicon114x114.png" /><link rel="icon" type="image/png" sizes="120x120" href="/cats/img/favicon120x120.png" /><link rel="icon" type="image/png" sizes="128x128" href="/cats/img/favicon128x128.png" /><link rel="icon" type="image/png" sizes="144x144" href="/cats/img/favicon144x144.png" /><link rel="icon" type="image/png" sizes="150x150" href="/cats/img/favicon150x150.png" /><link rel="icon" type="image/png" sizes="152x152" href="/cats/img/favicon152x152.png" /><link rel="icon" type="image/png" sizes="196x196" href="/cats/img/favicon196x196.png" /><link rel="icon" type="image/png" sizes="310x310" href="/cats/img/favicon310x310.png" /><link rel="icon" type="image/png" sizes="310x150" href="/cats/img/favicon310x150.png" /><link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css" /><link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css" /><link rel="stylesheet" href="/cats/highlight/styles/atom-one-light.css" /><link rel="stylesheet" href="/cats/css/style.css" /><link rel="stylesheet" href="/cats/css/palette.css" /><link rel="stylesheet" href="/cats/css/codemirror.css" /><link rel="stylesheet" href="/cats/css/override.css" /></head><body class="docs"><div id="wrapper"><div id="sidebar-wrapper"><ul id="sidebar" class="sidebar-nav"><li class="sidebar-brand"><a href="/cats/" class="brand"><div class="brand-wrapper"><span>Cats</span></div></a></li>                  <li><a href="/cats/datatypes.html" class="">Data Types</a></li> <li><a href="/cats/datatypes/chain.html" class="">Chain</a></li> <li><a href="/cats/datatypes/const.html" class=" active ">Const</a></li> <li><a href="/cats/datatypes/either.html" class="">Either</a></li> <li><a href="/cats/datatypes/eval.html" class="">Eval</a></li> <li><a href="/cats/datatypes/freeapplicative.html" class="">FreeApplicatives</a></li> <li><a href="/cats/datatypes/freemonad.html" class="">FreeMonads</a></li> <li><a href="/cats/datatypes/functionk.html" class="">FunctionK</a></li> <li><a href="/cats/datatypes/id.html" class="">Id</a></li> <li><a href="/cats/datatypes/ior.html" class="">Ior</a></li> <li><a href="/cats/datatypes/kleisli.html" class="">Kleisli</a></li> <li><a href="/cats/datatypes/nested.html" class="">Nested</a></li> <li><a href="/cats/datatypes/nel.html" class="">NonEmptyList</a></li> <li><a href="/cats/datatypes/oneand.html" class="">OneAnd</a></li> <li><a href="/cats/datatypes/optiont.html" class="">OptionT</a></li> <li><a href="/cats/datatypes/eithert.html" class="">EitherT</a></li> <li><a href="/cats/datatypes/iort.html" class="">IorT</a></li> <li><a href="/cats/datatypes/state.html" class="">State</a></li> <li><a href="/cats/datatypes/validated.html" class="">Validated</a></li></ul></div><div id="page-content-wrapper"><div class="nav"><div class="container-fluid"><div class="row"><div class="col-lg-12"><div class="action-menu pull-left clearfix"><a href="#menu-toggle" id="menu-toggle"><i class="fa fa-bars" aria-hidden="true"></i></a></div><ul class="pull-right"><li id="gh-eyes-item" class="hidden-xs"><a href="https://github.com/typelevel/cats"><i class="fa fa-eye"></i><span>WATCH<span id="eyes" class="label label-default">--</span></span></a></li><li id="gh-stars-item" class="hidden-xs"><a href="https://github.com/typelevel/cats"><i class="fa fa-star-o"></i><span>STARS<span id="stars" class="label label-default">--</span></span></a></li><li><a href="#" onclick="shareSiteTwitter('Cats Lightweight, modular, and extensible library for functional programming');"><i class="fa fa-twitter"></i></a></li><li><a href="#" onclick="shareSiteFacebook('Cats Lightweight, modular, and extensible library for functional programming');"><i class="fa fa-facebook"></i></a></li><li><a href="#" onclick="shareSiteGoogle();"><i class="fa fa-google-plus"></i></a></li></ul></div></div></div></div><div id="content" data-github-owner="typelevel" data-github-repo="cats"><div class="content-wrapper"><section><h1 id="const">Const</h1>
<p>At first glance <code class="highlighter-rouge">Const</code> seems like a strange data type - it has two type parameters, yet only
stores a value of the first type. What possible use is it? As it turns out, it does
have its uses, which serve as a nice example of the consistency and elegance of functional programming.</p>

<h2 id="thinking-about-const">Thinking about <code class="highlighter-rouge">Const</code></h2>
<p>The <code class="highlighter-rouge">Const</code> data type can be thought of similarly to the <code class="highlighter-rouge">const</code> function, but as a data type.</p>

<div class="language-scala highlighter-rouge"><pre class="codehilite"><code><span class="k">def</span> <span class="n">const</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">](</span><span class="n">a</span><span class="k">:</span> <span class="kt">A</span><span class="o">)(</span><span class="n">b</span><span class="k">:</span> <span class="o">=&gt;</span> <span class="n">B</span><span class="o">)</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=</span> <span class="n">a</span>
</code></pre></div>

<p>The <code class="highlighter-rouge">const</code> function takes two arguments and simply returns the first argument, ignoring the second.</p>

<div class="language-scala highlighter-rouge"><pre class="codehilite"><code><span class="k">final</span> <span class="k">case</span> <span class="k">class</span> <span class="nc">Const</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">](</span><span class="n">getConst</span><span class="k">:</span> <span class="kt">A</span><span class="o">)</span>
</code></pre></div>

<p>The <code class="highlighter-rouge">Const</code> data type takes two type parameters, but only ever stores a value of the first type parameter.
Because the second type parameter is not used in the data type, the type parameter is referred to as a
“phantom type”.</p>

<h2 id="why-do-we-care">Why do we care?</h2>
<p>It would seem <code class="highlighter-rouge">Const</code> gives us no benefit over a data type that would simply not have the second type parameter.
However, while we don’t directly use the second type parameter, its existence becomes useful in certain contexts.</p>

<h3 id="example-1-lens">Example 1: Lens</h3>
<p>The following is heavily inspired by <a href="https://github.com/julien-truffaut">Julien Truffaut</a>’s
<a href="http://functional-wizardry.blogspot.co.uk/2014/02/lens-implementation-part-1.html">blog post</a> on
<a href="https://github.com/julien-truffaut/Monocle">Monocle</a>, a fully-fledged optics library in Scala.</p>

<p>Types that contain other types are common across many programming paradigms. It is of course desirable in many
cases to get out members of other types, or to set them. In traditional object-oriented programming this is
handled by getter and setter methods on the outer object. In functional programming, a popular solution is
to use a lens.</p>

<p>A lens can be thought of as a first class getter/setter. A <code class="highlighter-rouge">Lens[S, A]</code> is a data type that knows how to get
an <code class="highlighter-rouge">A</code> out of an <code class="highlighter-rouge">S</code>, or set an <code class="highlighter-rouge">A</code> in an <code class="highlighter-rouge">S</code>.</p>

<div class="language-scala highlighter-rouge"><pre class="codehilite"><code><span class="k">trait</span> <span class="nc">Lens</span><span class="o">[</span><span class="kt">S</span>, <span class="kt">A</span><span class="o">]</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">get</span><span class="o">(</span><span class="n">s</span><span class="k">:</span> <span class="kt">S</span><span class="o">)</span><span class="k">:</span> <span class="kt">A</span>

  <span class="k">def</span> <span class="n">set</span><span class="o">(</span><span class="n">s</span><span class="k">:</span> <span class="kt">S</span><span class="o">,</span> <span class="n">a</span><span class="k">:</span> <span class="kt">A</span><span class="o">)</span><span class="k">:</span> <span class="kt">S</span>

  <span class="k">def</span> <span class="n">modify</span><span class="o">(</span><span class="n">s</span><span class="k">:</span> <span class="kt">S</span><span class="o">)(</span><span class="n">f</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="n">A</span><span class="o">)</span><span class="k">:</span> <span class="kt">S</span> <span class="o">=</span>
    <span class="n">set</span><span class="o">(</span><span class="n">s</span><span class="o">,</span> <span class="n">f</span><span class="o">(</span><span class="n">get</span><span class="o">(</span><span class="n">s</span><span class="o">)))</span>
<span class="o">}</span>
</code></pre></div>

<p>It can be useful to have effectful modifications as well - perhaps our modification can fail (<code class="highlighter-rouge">Option</code>) or
can return several values (<code class="highlighter-rouge">List</code>).</p>

<div class="language-scala highlighter-rouge"><pre class="codehilite"><code><span class="k">trait</span> <span class="nc">Lens</span><span class="o">[</span><span class="kt">S</span>, <span class="kt">A</span><span class="o">]</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">get</span><span class="o">(</span><span class="n">s</span><span class="k">:</span> <span class="kt">S</span><span class="o">)</span><span class="k">:</span> <span class="kt">A</span>

  <span class="k">def</span> <span class="n">set</span><span class="o">(</span><span class="n">s</span><span class="k">:</span> <span class="kt">S</span><span class="o">,</span> <span class="n">a</span><span class="k">:</span> <span class="kt">A</span><span class="o">)</span><span class="k">:</span> <span class="kt">S</span>

  <span class="k">def</span> <span class="n">modify</span><span class="o">(</span><span class="n">s</span><span class="k">:</span> <span class="kt">S</span><span class="o">)(</span><span class="n">f</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="n">A</span><span class="o">)</span><span class="k">:</span> <span class="kt">S</span> <span class="o">=</span>
    <span class="n">set</span><span class="o">(</span><span class="n">s</span><span class="o">,</span> <span class="n">f</span><span class="o">(</span><span class="n">get</span><span class="o">(</span><span class="n">s</span><span class="o">)))</span>

  <span class="k">def</span> <span class="n">modifyOption</span><span class="o">(</span><span class="n">s</span><span class="k">:</span> <span class="kt">S</span><span class="o">)(</span><span class="n">f</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="nc">Option</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">S</span><span class="o">]</span> <span class="k">=</span>
    <span class="n">f</span><span class="o">(</span><span class="n">get</span><span class="o">(</span><span class="n">s</span><span class="o">)).</span><span class="n">map</span><span class="o">(</span><span class="n">a</span> <span class="k">=&gt;</span> <span class="n">set</span><span class="o">(</span><span class="n">s</span><span class="o">,</span> <span class="n">a</span><span class="o">))</span>

  <span class="k">def</span> <span class="n">modifyList</span><span class="o">(</span><span class="n">s</span><span class="k">:</span> <span class="kt">S</span><span class="o">)(</span><span class="n">f</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="nc">List</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">S</span><span class="o">]</span> <span class="k">=</span>
    <span class="n">f</span><span class="o">(</span><span class="n">get</span><span class="o">(</span><span class="n">s</span><span class="o">)).</span><span class="n">map</span><span class="o">(</span><span class="n">a</span> <span class="k">=&gt;</span> <span class="n">set</span><span class="o">(</span><span class="n">s</span><span class="o">,</span> <span class="n">a</span><span class="o">))</span>
<span class="o">}</span>
</code></pre></div>

<p>Note that both <code class="highlighter-rouge">modifyOption</code> and <code class="highlighter-rouge">modifyList</code> share the <em>exact</em> same implementation. If we look closely, the
only thing we need is a <code class="highlighter-rouge">map</code> operation on the data type. Being good functional programmers, we abstract.</p>

<div class="language-scala highlighter-rouge"><pre class="codehilite"><code><span class="k">import</span> <span class="nn">cats.Functor</span>
<span class="k">import</span> <span class="nn">cats.implicits._</span>

<span class="k">trait</span> <span class="nc">Lens</span><span class="o">[</span><span class="kt">S</span>, <span class="kt">A</span><span class="o">]</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">get</span><span class="o">(</span><span class="n">s</span><span class="k">:</span> <span class="kt">S</span><span class="o">)</span><span class="k">:</span> <span class="kt">A</span>

  <span class="k">def</span> <span class="n">set</span><span class="o">(</span><span class="n">s</span><span class="k">:</span> <span class="kt">S</span><span class="o">,</span> <span class="n">a</span><span class="k">:</span> <span class="kt">A</span><span class="o">)</span><span class="k">:</span> <span class="kt">S</span>

  <span class="k">def</span> <span class="n">modify</span><span class="o">(</span><span class="n">s</span><span class="k">:</span> <span class="kt">S</span><span class="o">)(</span><span class="n">f</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="n">A</span><span class="o">)</span><span class="k">:</span> <span class="kt">S</span> <span class="o">=</span>
    <span class="n">set</span><span class="o">(</span><span class="n">s</span><span class="o">,</span> <span class="n">f</span><span class="o">(</span><span class="n">get</span><span class="o">(</span><span class="n">s</span><span class="o">)))</span>

  <span class="k">def</span> <span class="n">modifyF</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span> <span class="kt">:</span> <span class="kt">Functor</span><span class="o">](</span><span class="n">s</span><span class="k">:</span> <span class="kt">S</span><span class="o">)(</span><span class="n">f</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="n">F</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">S</span><span class="o">]</span> <span class="k">=</span>
    <span class="n">f</span><span class="o">(</span><span class="n">get</span><span class="o">(</span><span class="n">s</span><span class="o">)).</span><span class="n">map</span><span class="o">(</span><span class="n">a</span> <span class="k">=&gt;</span> <span class="n">set</span><span class="o">(</span><span class="n">s</span><span class="o">,</span> <span class="n">a</span><span class="o">))</span>
<span class="o">}</span>
</code></pre></div>

<p>We can redefine <code class="highlighter-rouge">modify</code> in terms of <code class="highlighter-rouge">modifyF</code> by using <code class="highlighter-rouge">cats.Id</code>. We can also treat <code class="highlighter-rouge">set</code> as a modification
that simply ignores the current value. Due to these modifications however, we must leave <code class="highlighter-rouge">modifyF</code> abstract
since having it defined in terms of <code class="highlighter-rouge">set</code> would lead to infinite circular calls.</p>

<div class="language-scala highlighter-rouge"><pre class="codehilite"><code><span class="k">import</span> <span class="nn">cats.Id</span>

<span class="k">trait</span> <span class="nc">Lens</span><span class="o">[</span><span class="kt">S</span>, <span class="kt">A</span><span class="o">]</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">modifyF</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span> <span class="kt">:</span> <span class="kt">Functor</span><span class="o">](</span><span class="n">s</span><span class="k">:</span> <span class="kt">S</span><span class="o">)(</span><span class="n">f</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="n">F</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">S</span><span class="o">]</span>

  <span class="k">def</span> <span class="n">set</span><span class="o">(</span><span class="n">s</span><span class="k">:</span> <span class="kt">S</span><span class="o">,</span> <span class="n">a</span><span class="k">:</span> <span class="kt">A</span><span class="o">)</span><span class="k">:</span> <span class="kt">S</span> <span class="o">=</span> <span class="n">modify</span><span class="o">(</span><span class="n">s</span><span class="o">)(</span><span class="k">_</span> <span class="k">=&gt;</span> <span class="n">a</span><span class="o">)</span>

  <span class="k">def</span> <span class="n">modify</span><span class="o">(</span><span class="n">s</span><span class="k">:</span> <span class="kt">S</span><span class="o">)(</span><span class="n">f</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="n">A</span><span class="o">)</span><span class="k">:</span> <span class="kt">S</span> <span class="o">=</span> <span class="n">modifyF</span><span class="o">[</span><span class="kt">Id</span><span class="o">](</span><span class="n">s</span><span class="o">)(</span><span class="n">f</span><span class="o">)</span>

  <span class="k">def</span> <span class="n">get</span><span class="o">(</span><span class="n">s</span><span class="k">:</span> <span class="kt">S</span><span class="o">)</span><span class="k">:</span> <span class="kt">A</span>
<span class="o">}</span>
</code></pre></div>

<p>What about <code class="highlighter-rouge">get</code>? Certainly we can’t define <code class="highlighter-rouge">get</code> in terms of the others.. the others are to modify an existing
value, whereas <code class="highlighter-rouge">get</code> is to retrieve it. Let’s give it a shot anyways.</p>

<p>Looking at <code class="highlighter-rouge">modifyF</code>, we have an <code class="highlighter-rouge">S</code> we can pass in. The tricky part will be the <code class="highlighter-rouge">A =&gt; F[A]</code>, and then somehow
getting an <code class="highlighter-rouge">A</code> out of <code class="highlighter-rouge">F[S]</code>. If we imagine <code class="highlighter-rouge">F</code> to be a type-level constant function however, we could imagine
it would simply take any type and return some other constant type, an <code class="highlighter-rouge">A</code> perhaps. This suggests our <code class="highlighter-rouge">F</code> is a
<code class="highlighter-rouge">Const</code>.</p>

<p>We then take a look at the fact that <code class="highlighter-rouge">modifyF</code> takes an <code class="highlighter-rouge">F[_]</code>, a type constructor that takes a single type parameter.
<code class="highlighter-rouge">Const</code> takes two, so we must fix one. The function returns an <code class="highlighter-rouge">F[S]</code>, but we want an <code class="highlighter-rouge">A</code>, which implies we
have the first type parameter fixed to <code class="highlighter-rouge">A</code> and leave the second one free for the function to fill in as it wants.</p>

<p>Substituting in <code class="highlighter-rouge">Const[A, _]</code> wherever we see <code class="highlighter-rouge">F[_]</code>, the function wants an <code class="highlighter-rouge">A =&gt; Const[A, A]</code> and will give us back
a <code class="highlighter-rouge">Const[A, S]</code>. Looking at the definition of <code class="highlighter-rouge">Const</code>, we see that we only ever have a value of the first type parameter
and completely ignore the second. Therefore, we can treat any <code class="highlighter-rouge">Const[X, Y]</code> value as equivalent to <code class="highlighter-rouge">X</code> (plus or minus
some wrapping into <code class="highlighter-rouge">Const</code>). This leaves us with needing a function <code class="highlighter-rouge">A =&gt; A</code>. Given the type, the only thing we can do
is to take an <code class="highlighter-rouge">A</code> and return it right back (lifted into <code class="highlighter-rouge">Const</code>).</p>

<p>Before we plug and play however, note that <code class="highlighter-rouge">modifyF</code> has a <code class="highlighter-rouge">Functor</code> constraint on <code class="highlighter-rouge">F[_]</code>. This means we need to
define a <code class="highlighter-rouge">Functor</code> instance for <code class="highlighter-rouge">Const</code>, where the first type parameter is fixed.</p>

<p><em>Note</em>: the example below assumes usage of the <a href="https://github.com/non/kind-projector">kind-projector compiler plugin</a> and will not compile if it is not being used in a project.</p>

<div class="language-scala highlighter-rouge"><pre class="codehilite"><code><span class="k">import</span> <span class="nn">cats.data.Const</span>

<span class="k">implicit</span> <span class="k">def</span> <span class="n">constFunctor</span><span class="o">[</span><span class="kt">X</span><span class="o">]</span><span class="k">:</span> <span class="kt">Functor</span><span class="o">[</span><span class="kt">Const</span><span class="o">[</span><span class="kt">X</span>, <span class="kt">?</span><span class="o">]]</span> <span class="k">=</span>
  <span class="k">new</span> <span class="nc">Functor</span><span class="o">[</span><span class="kt">Const</span><span class="o">[</span><span class="kt">X</span>, <span class="kt">?</span><span class="o">]]</span> <span class="o">{</span>
    <span class="c1">// Recall Const[X, A] ~= X, so the function is not of any use to us
</span>    <span class="k">def</span> <span class="n">map</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">](</span><span class="n">fa</span><span class="k">:</span> <span class="kt">Const</span><span class="o">[</span><span class="kt">X</span>, <span class="kt">A</span><span class="o">])(</span><span class="n">f</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="n">B</span><span class="o">)</span><span class="k">:</span> <span class="kt">Const</span><span class="o">[</span><span class="kt">X</span>, <span class="kt">B</span><span class="o">]</span> <span class="k">=</span>
      <span class="nc">Const</span><span class="o">(</span><span class="n">fa</span><span class="o">.</span><span class="n">getConst</span><span class="o">)</span>
  <span class="o">}</span>
</code></pre></div>

<p>Now that that’s taken care of, let’s substitute and see what happens.</p>

<div class="language-scala highlighter-rouge"><pre class="codehilite"><code><span class="k">trait</span> <span class="nc">Lens</span><span class="o">[</span><span class="kt">S</span>, <span class="kt">A</span><span class="o">]</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">modifyF</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span> <span class="kt">:</span> <span class="kt">Functor</span><span class="o">](</span><span class="n">s</span><span class="k">:</span> <span class="kt">S</span><span class="o">)(</span><span class="n">f</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="n">F</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">S</span><span class="o">]</span>

  <span class="k">def</span> <span class="n">set</span><span class="o">(</span><span class="n">s</span><span class="k">:</span> <span class="kt">S</span><span class="o">,</span> <span class="n">a</span><span class="k">:</span> <span class="kt">A</span><span class="o">)</span><span class="k">:</span> <span class="kt">S</span> <span class="o">=</span> <span class="n">modify</span><span class="o">(</span><span class="n">s</span><span class="o">)(</span><span class="k">_</span> <span class="k">=&gt;</span> <span class="n">a</span><span class="o">)</span>

  <span class="k">def</span> <span class="n">modify</span><span class="o">(</span><span class="n">s</span><span class="k">:</span> <span class="kt">S</span><span class="o">)(</span><span class="n">f</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="n">A</span><span class="o">)</span><span class="k">:</span> <span class="kt">S</span> <span class="o">=</span> <span class="n">modifyF</span><span class="o">[</span><span class="kt">Id</span><span class="o">](</span><span class="n">s</span><span class="o">)(</span><span class="n">f</span><span class="o">)</span>

  <span class="k">def</span> <span class="n">get</span><span class="o">(</span><span class="n">s</span><span class="k">:</span> <span class="kt">S</span><span class="o">)</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=</span> <span class="o">{</span>
    <span class="k">val</span> <span class="n">storedValue</span> <span class="k">=</span> <span class="n">modifyF</span><span class="o">[</span><span class="kt">Const</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">?</span><span class="o">]](</span><span class="n">s</span><span class="o">)(</span><span class="n">a</span> <span class="k">=&gt;</span> <span class="nc">Const</span><span class="o">(</span><span class="n">a</span><span class="o">))</span>
    <span class="n">storedValue</span><span class="o">.</span><span class="n">getConst</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></div>

<p>It works! We get a <code class="highlighter-rouge">Const[A, S]</code> out on the other side, and we simply just retrieve the <code class="highlighter-rouge">A</code> value stored inside.</p>

<p>What’s going on here? We can treat the effectful “modification” we are doing as a store operation - we take an <code class="highlighter-rouge">A</code>
and store it inside a <code class="highlighter-rouge">Const</code>. Knowing only <code class="highlighter-rouge">F[_]</code> has a <code class="highlighter-rouge">Functor</code> instance, it can only <code class="highlighter-rouge">map</code> over the <code class="highlighter-rouge">Const</code>
which will do nothing to the stored value. After <code class="highlighter-rouge">modifyF</code> is done getting the new <code class="highlighter-rouge">S</code>, we retrieve the stored <code class="highlighter-rouge">A</code>
value and we’re done!</p>

<h3 id="example-2-traverse">Example 2: Traverse</h3>
<p>In the popular <a href="https://www.cs.ox.ac.uk/jeremy.gibbons/publications/iterator.pdf">The Essence of the Iterator Pattern</a>
paper, Jeremy Gibbons and Bruno C. d. S. Oliveria describe a functional approach to iterating over a collection of
data. Among the abstractions presented are <code class="highlighter-rouge">Foldable</code> and <code class="highlighter-rouge">Traverse</code>, replicated below (also available in Cats).</p>

<div class="language-scala highlighter-rouge"><pre class="codehilite"><code><span class="k">import</span> <span class="nn">cats.</span><span class="o">{</span><span class="nc">Applicative</span><span class="o">,</span> <span class="nc">Monoid</span><span class="o">}</span>

<span class="k">trait</span> <span class="nc">Foldable</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]]</span> <span class="o">{</span>
  <span class="c1">// Given a collection of data F[A], and a function mapping each A to a B where B has a Monoid instance,
</span>  <span class="c1">// reduce the collection down to a single B value using the monoidal behavior of B
</span>  <span class="k">def</span> <span class="n">foldMap</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span> <span class="kt">:</span> <span class="kt">Monoid</span><span class="o">](</span><span class="n">fa</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">])(</span><span class="n">f</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="n">B</span><span class="o">)</span><span class="k">:</span> <span class="kt">B</span>
<span class="o">}</span>

<span class="k">trait</span> <span class="nc">Traverse</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]]</span> <span class="o">{</span>
  <span class="c1">// Given a collection of data F[A], for each value apply the function f which returns an effectful
</span>  <span class="c1">// value. The result of traverse is the composition of all these effectful values.
</span>  <span class="k">def</span> <span class="n">traverse</span><span class="o">[</span><span class="kt">G</span><span class="o">[</span><span class="k">_</span><span class="o">]</span> <span class="kt">:</span> <span class="kt">Applicative</span>, <span class="kt">A</span>, <span class="kt">B</span><span class="o">](</span><span class="n">fa</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">])(</span><span class="n">f</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="n">G</span><span class="o">[</span><span class="kt">B</span><span class="o">])</span><span class="k">:</span> <span class="kt">G</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="kt">B</span><span class="o">]]</span>
<span class="o">}</span>
</code></pre></div>

<p>These two type classes seem unrelated - one reduces a collection down to a single value, the other traverses
a collection with an effectful function, collecting results. It may be surprising to see that in fact <code class="highlighter-rouge">Traverse</code>
subsumes <code class="highlighter-rouge">Foldable</code>.</p>

<div class="language-scala highlighter-rouge"><pre class="codehilite"><code><span class="k">trait</span> <span class="nc">Traverse</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]]</span> <span class="nc">extends</span> <span class="nc">Foldable</span><span class="o">[</span><span class="kt">F</span><span class="o">]</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">traverse</span><span class="o">[</span><span class="kt">G</span><span class="o">[</span><span class="k">_</span><span class="o">]</span> <span class="kt">:</span> <span class="kt">Applicative</span>, <span class="kt">A</span>, <span class="kt">X</span><span class="o">](</span><span class="n">fa</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">])(</span><span class="n">f</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="n">G</span><span class="o">[</span><span class="kt">X</span><span class="o">])</span><span class="k">:</span> <span class="kt">G</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="kt">X</span><span class="o">]]</span>

  <span class="k">def</span> <span class="n">foldMap</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span> <span class="kt">:</span> <span class="kt">Monoid</span><span class="o">](</span><span class="n">fa</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">])(</span><span class="n">f</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="n">B</span><span class="o">)</span><span class="k">:</span> <span class="kt">B</span>
<span class="o">}</span>
</code></pre></div>

<p>To start, we observe that if we are to implement <code class="highlighter-rouge">foldMap</code> in terms of <code class="highlighter-rouge">traverse</code>, we will want a <code class="highlighter-rouge">B</code> out
at some point. However, <code class="highlighter-rouge">traverse</code> returns a <code class="highlighter-rouge">G[F[X]]</code>. It would seem there is no way to unify these two.
However, if we imagine <code class="highlighter-rouge">G[_]</code> to be a sort of type-level constant function, where the fact that it’s taking a
<code class="highlighter-rouge">F[X]</code> is irrelevant to the true underlying value, we can begin to see how we might be able to pull this off.</p>

<p><code class="highlighter-rouge">traverse</code> however wants <code class="highlighter-rouge">G[_]</code> to have an <code class="highlighter-rouge">Applicative</code> instance, so let’s define one for <code class="highlighter-rouge">Const</code>. Since
<code class="highlighter-rouge">F[X]</code> is the value we want to ignore, we treat it as the second type parameter and hence, leave it as the free
one.</p>

<div class="language-scala highlighter-rouge"><pre class="codehilite"><code><span class="k">import</span> <span class="nn">cats.data.Const</span>

<span class="k">implicit</span> <span class="k">def</span> <span class="n">constApplicative</span><span class="o">[</span><span class="kt">Z</span><span class="o">]</span><span class="k">:</span> <span class="kt">Applicative</span><span class="o">[</span><span class="kt">Const</span><span class="o">[</span><span class="kt">Z</span>, <span class="kt">?</span><span class="o">]]</span> <span class="k">=</span>
  <span class="k">new</span> <span class="nc">Applicative</span><span class="o">[</span><span class="kt">Const</span><span class="o">[</span><span class="kt">Z</span>, <span class="kt">?</span><span class="o">]]</span> <span class="o">{</span>
    <span class="k">def</span> <span class="n">pure</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">a</span><span class="k">:</span> <span class="kt">A</span><span class="o">)</span><span class="k">:</span> <span class="kt">Const</span><span class="o">[</span><span class="kt">Z</span>, <span class="kt">A</span><span class="o">]</span> <span class="k">=</span> <span class="o">???</span>

    <span class="k">def</span> <span class="n">ap</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">](</span><span class="n">f</span><span class="k">:</span> <span class="kt">Const</span><span class="o">[</span><span class="kt">Z</span>, <span class="kt">A</span> <span class="k">=&gt;</span> <span class="kt">B</span><span class="o">])(</span><span class="n">fa</span><span class="k">:</span> <span class="kt">Const</span><span class="o">[</span><span class="kt">Z</span>, <span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">Const</span><span class="o">[</span><span class="kt">Z</span>, <span class="kt">B</span><span class="o">]</span> <span class="k">=</span> <span class="o">???</span>
  <span class="o">}</span>
</code></pre></div>

<p>Recall that <code class="highlighter-rouge">Const[Z, A]</code> means we have a <code class="highlighter-rouge">Z</code> value in hand, and don’t really care about the <code class="highlighter-rouge">A</code> type parameter.
Therefore we can more or less treat the type <code class="highlighter-rouge">Const[Z, A]</code> as just <code class="highlighter-rouge">Z</code>.</p>

<p>In functions <code class="highlighter-rouge">pure</code> and <code class="highlighter-rouge">ap</code> we have a problem. In <code class="highlighter-rouge">pure</code>, we have an <code class="highlighter-rouge">A</code> value, but want to return a <code class="highlighter-rouge">Z</code> value. We have
no function <code class="highlighter-rouge">A =&gt; Z</code>, so our only option is to completely ignore the <code class="highlighter-rouge">A</code> value. But we still don’t have a <code class="highlighter-rouge">Z</code>! Let’s
put that aside for now, but still keep it in the back of our minds.</p>

<p>In <code class="highlighter-rouge">ap</code> we have two <code class="highlighter-rouge">Z</code> values, and want to return a <code class="highlighter-rouge">Z</code> value. We could certainly return one or the other, but we
should try to do something more useful. This suggests composition of <code class="highlighter-rouge">Z</code>s, which we don’t know how to do.</p>

<p>So now we need a constant <code class="highlighter-rouge">Z</code> value, and a binary function that takes two <code class="highlighter-rouge">Z</code>s and produces a <code class="highlighter-rouge">Z</code>. Sound familiar?
We want <code class="highlighter-rouge">Z</code> to have a <code class="highlighter-rouge">Monoid</code> instance!</p>

<div class="language-scala highlighter-rouge"><pre class="codehilite"><code><span class="k">implicit</span> <span class="k">def</span> <span class="n">constApplicative</span><span class="o">[</span><span class="kt">Z</span> <span class="kt">:</span> <span class="kt">Monoid</span><span class="o">]</span><span class="k">:</span> <span class="kt">Applicative</span><span class="o">[</span><span class="kt">Const</span><span class="o">[</span><span class="kt">Z</span>, <span class="kt">?</span><span class="o">]]</span> <span class="k">=</span>
  <span class="k">new</span> <span class="nc">Applicative</span><span class="o">[</span><span class="kt">Const</span><span class="o">[</span><span class="kt">Z</span>, <span class="kt">?</span><span class="o">]]</span> <span class="o">{</span>
    <span class="k">def</span> <span class="n">pure</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">a</span><span class="k">:</span> <span class="kt">A</span><span class="o">)</span><span class="k">:</span> <span class="kt">Const</span><span class="o">[</span><span class="kt">Z</span>, <span class="kt">A</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Const</span><span class="o">(</span><span class="nc">Monoid</span><span class="o">[</span><span class="kt">Z</span><span class="o">].</span><span class="n">empty</span><span class="o">)</span>

    <span class="k">def</span> <span class="n">ap</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">](</span><span class="n">f</span><span class="k">:</span> <span class="kt">Const</span><span class="o">[</span><span class="kt">Z</span>, <span class="kt">A</span> <span class="k">=&gt;</span> <span class="kt">B</span><span class="o">])(</span><span class="n">fa</span><span class="k">:</span> <span class="kt">Const</span><span class="o">[</span><span class="kt">Z</span>, <span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">Const</span><span class="o">[</span><span class="kt">Z</span>, <span class="kt">B</span><span class="o">]</span> <span class="k">=</span>
      <span class="nc">Const</span><span class="o">(</span><span class="nc">Monoid</span><span class="o">[</span><span class="kt">Z</span><span class="o">].</span><span class="n">combine</span><span class="o">(</span><span class="n">fa</span><span class="o">.</span><span class="n">getConst</span><span class="o">,</span> <span class="n">f</span><span class="o">.</span><span class="n">getConst</span><span class="o">))</span>
  <span class="o">}</span>
</code></pre></div>

<p>We have our <code class="highlighter-rouge">Applicative</code>!</p>

<p>Going back to <code class="highlighter-rouge">Traverse</code>, we fill in the first parameter of <code class="highlighter-rouge">traverse</code> with <code class="highlighter-rouge">fa</code> since that’s
the only value that fits.</p>

<p>Now we need a <code class="highlighter-rouge">A =&gt; G[B]</code>. We have an <code class="highlighter-rouge">A =&gt; B</code>, and we’ve decided to use <code class="highlighter-rouge">Const</code> for our <code class="highlighter-rouge">G[_]</code>. We need to
fix the first parameter of <code class="highlighter-rouge">Const</code> since <code class="highlighter-rouge">Const</code> takes two type parameters and <code class="highlighter-rouge">traverse</code> wants a type constructor
which only takes one. The first type parameter which will be the type of the actual values we store, and therefore will
be the type of the value we get out at the end, so we leave the second one free, similar to the <code class="highlighter-rouge">Applicative</code> instance.
We don’t care about the second type parameter and there are no restrictions on it, so we can just use <code class="highlighter-rouge">Nothing</code>,
the type that has no values.</p>

<p>So to summarize, what we want is a function <code class="highlighter-rouge">A =&gt; Const[B, Nothing]</code>, and we have a function <code class="highlighter-rouge">A =&gt; B</code>. Recall
that <code class="highlighter-rouge">Const[B, Z]</code> (for any <code class="highlighter-rouge">Z</code>) is the moral equivalent of just <code class="highlighter-rouge">B</code>, so <code class="highlighter-rouge">A =&gt; Const[B, Nothing]</code> is equivalent
to <code class="highlighter-rouge">A =&gt; B</code>, which is exactly what we have, we just need to wrap it.</p>

<div class="language-scala highlighter-rouge"><pre class="codehilite"><code><span class="k">trait</span> <span class="nc">Traverse</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]]</span> <span class="nc">extends</span> <span class="nc">Foldable</span><span class="o">[</span><span class="kt">F</span><span class="o">]</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">traverse</span><span class="o">[</span><span class="kt">G</span><span class="o">[</span><span class="k">_</span><span class="o">]</span> <span class="kt">:</span> <span class="kt">Applicative</span>, <span class="kt">A</span>, <span class="kt">X</span><span class="o">](</span><span class="n">fa</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">])(</span><span class="n">f</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="n">G</span><span class="o">[</span><span class="kt">X</span><span class="o">])</span><span class="k">:</span> <span class="kt">G</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="kt">X</span><span class="o">]]</span>

  <span class="k">def</span> <span class="n">foldMap</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span> <span class="kt">:</span> <span class="kt">Monoid</span><span class="o">](</span><span class="n">fa</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">])(</span><span class="n">f</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="n">B</span><span class="o">)</span><span class="k">:</span> <span class="kt">B</span> <span class="o">=</span> <span class="o">{</span>
    <span class="k">val</span> <span class="n">const</span><span class="k">:</span> <span class="kt">Const</span><span class="o">[</span><span class="kt">B</span>, <span class="kt">F</span><span class="o">[</span><span class="kt">Nothing</span><span class="o">]]</span> <span class="k">=</span> <span class="n">traverse</span><span class="o">[</span><span class="kt">Const</span><span class="o">[</span><span class="kt">B</span>, <span class="kt">?</span><span class="o">]</span>, <span class="kt">A</span>, <span class="kt">Nothing</span><span class="o">](</span><span class="n">fa</span><span class="o">)(</span><span class="n">a</span> <span class="k">=&gt;</span> <span class="nc">Const</span><span class="o">(</span><span class="n">f</span><span class="o">(</span><span class="n">a</span><span class="o">)))</span>
    <span class="n">const</span><span class="o">.</span><span class="n">getConst</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></div>

<p>Hurrah!</p>

<p>What’s happening here? We can see <code class="highlighter-rouge">traverse</code> is a function that goes over a collection, applying an
effectful function to each value, and combining all of these effectful values. In our case, the effect
is mapping each value to a value of type <code class="highlighter-rouge">B</code>, where we know how to combine <code class="highlighter-rouge">B</code>s via its <code class="highlighter-rouge">Monoid</code> instance.
The <code class="highlighter-rouge">Monoid</code> instance is exactly what is used when <code class="highlighter-rouge">traverse</code> goes to collect the effectful values together.
Should the <code class="highlighter-rouge">F[A]</code> be “empty”, it can use <code class="highlighter-rouge">Monoid#empty</code> as a value to return back.</p>

<p>Pretty nifty. <code class="highlighter-rouge">traverse</code>-ing over a collection with an effectful function is more general than traversing
over a collection to reduce it down to a single value.</p>
</section></div></div></div></div><script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/1.11.3/jquery.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.3.7/js/bootstrap.min.js"></script><script src="/cats/highlight/highlight.pack.js"></script><script>hljs.configure({
languages:['scala','java','bash']
});
hljs.initHighlighting();
             </script><script>((window.gitter = {}).chat = {}).options = {
room: 'typelevel/cats'};</script><script src="https://sidecar.gitter.im/dist/sidecar.v1.js"></script><script src="/cats/js/main.js"></script></body></html>