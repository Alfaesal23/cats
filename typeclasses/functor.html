<html><head><title>Cats: Functor</title><meta charset="utf-8" /><meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" /><meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="author" content="Cats contributors" /><meta name="description" content="Lightweight, modular, and extensible library for functional programming" /><meta name="og:image" content="/cats/img/poster.png" /><meta name="og:title" content="Cats: Functor" /><meta name="og:site_name" content="Cats" /><meta name="og:url" content="http://typelevel.org/cats/" /><meta name="og:type" content="website" /><meta name="og:description" content="Lightweight, modular, and extensible library for functional programming" /><link rel="icon" type="image/png" href="/cats/img/favicon.png" /><meta name="twitter:title" content="Cats: Functor" /><meta name="twitter:image" content="http://typelevel.org/cats/img/poster.png" /><meta name="twitter:description" content="Lightweight, modular, and extensible library for functional programming" /><meta name="twitter:card" content="summary_large_image" /><link rel="icon" type="image/png" sizes="16x16" href="/cats/img/favicon16x16.png" /><link rel="icon" type="image/png" sizes="24x24" href="/cats/img/favicon24x24.png" /><link rel="icon" type="image/png" sizes="32x32" href="/cats/img/favicon32x32.png" /><link rel="icon" type="image/png" sizes="48x48" href="/cats/img/favicon48x48.png" /><link rel="icon" type="image/png" sizes="57x57" href="/cats/img/favicon57x57.png" /><link rel="icon" type="image/png" sizes="60x60" href="/cats/img/favicon60x60.png" /><link rel="icon" type="image/png" sizes="64x64" href="/cats/img/favicon64x64.png" /><link rel="icon" type="image/png" sizes="70x70" href="/cats/img/favicon70x70.png" /><link rel="icon" type="image/png" sizes="72x72" href="/cats/img/favicon72x72.png" /><link rel="icon" type="image/png" sizes="76x76" href="/cats/img/favicon76x76.png" /><link rel="icon" type="image/png" sizes="96x96" href="/cats/img/favicon96x96.png" /><link rel="icon" type="image/png" sizes="114x114" href="/cats/img/favicon114x114.png" /><link rel="icon" type="image/png" sizes="120x120" href="/cats/img/favicon120x120.png" /><link rel="icon" type="image/png" sizes="128x128" href="/cats/img/favicon128x128.png" /><link rel="icon" type="image/png" sizes="144x144" href="/cats/img/favicon144x144.png" /><link rel="icon" type="image/png" sizes="150x150" href="/cats/img/favicon150x150.png" /><link rel="icon" type="image/png" sizes="152x152" href="/cats/img/favicon152x152.png" /><link rel="icon" type="image/png" sizes="196x196" href="/cats/img/favicon196x196.png" /><link rel="icon" type="image/png" sizes="310x310" href="/cats/img/favicon310x310.png" /><link rel="icon" type="image/png" sizes="310x150" href="/cats/img/favicon310x150.png" /><link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css" /><link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css" /><link rel="stylesheet" href="/cats/highlight/styles/atom-one-light.css" /><link rel="stylesheet" href="/cats/css/style.css" /><link rel="stylesheet" href="/cats/css/palette.css" /><link rel="stylesheet" href="/cats/css/codemirror.css" /><link rel="stylesheet" href="/cats/css/override.css" /></head><body class="docs"><div id="wrapper"><div id="sidebar-wrapper"><ul id="sidebar" class="sidebar-nav"><li class="sidebar-brand"><a href="/cats/" class="brand"><div class="brand-wrapper"><span>Cats</span></div></a></li> <li><a href="/cats/typeclasses.html" class="">Type Classes</a></li> <li><a href="/cats/typeclasses/semigroup.html" class="">Semigroups and Monoids</a> <ul class="sub_section"> <li><a href="/cats/typeclasses/semigroup.html" class="">Semigroup</a></li> <li><a href="/cats/typeclasses/monoid.html" class="">Monoid</a></li></ul></li> <li><a href="/cats/typeclasses/applicativetraverse.html" class="">Applicative and Traversable Functors</a> <ul class="sub_section"> <li><a href="/cats/typeclasses/functor.html" class=" active ">Functor</a></li> <li><a href="/cats/typeclasses/applicative.html" class="">Applicative</a></li> <li><a href="/cats/typeclasses/traverse.html" class="">Traverse</a></li></ul></li> <li><a href="/cats/typeclasses/functor.html" class="">Monads</a> <ul class="sub_section"> <li><a href="/cats/typeclasses/functor.html" class=" active ">Functor</a></li> <li><a href="/cats/typeclasses/applicative.html" class="">Applicative</a></li> <li><a href="/cats/typeclasses/monad.html" class="">Monad</a></li></ul></li> <li><a href="/cats/typeclasses/functor.html" class="">Variance and Functors</a> <ul class="sub_section"> <li><a href="/cats/typeclasses/functor.html" class=" active ">Functor</a></li> <li><a href="/cats/typeclasses/contravariant.html" class="">Contravariant</a></li> <li><a href="/cats/typeclasses/contravariantmonoidal.html" class="">ContravariantMonoidal</a></li> <li><a href="/cats/typeclasses/invariant.html" class="">Invariant</a></li> <li><a href="/cats/typeclasses/invariantmonoidal.html" class="">InvariantMonoidal</a></li></ul></li> <li><a href="/cats/typeclasses/eq.html" class="">Eq</a></li> <li><a href="/cats/typeclasses/foldable.html" class="">Foldable</a></li> <li><a href="/cats/typeclasses/parallel.html" class="">Parallel</a></li> <li><a href="/cats/typeclasses/semigroupk.html" class="">SemigroupK</a></li> <li><a href="/cats/typeclasses/monoidk.html" class="">MonoidK</a></li> <li><a href="/cats/typeclasses/show.html" class="">Show</a></li> <li><a href="/cats/typeclasses/reducible.html" class="">Reducible</a></li> <li><a href="/cats/typeclasses/nonemptytraverse.html" class="">NonEmptyTraverse</a></li> <li><a href="/cats/typeclasses/arrow.html" class="">Arrow</a></li> <li><a href="/cats/typeclasses/lawtesting.html" class="">Law Testing</a></li>                  </ul></div><div id="page-content-wrapper"><div class="nav"><div class="container-fluid"><div class="row"><div class="col-lg-12"><div class="action-menu pull-left clearfix"><a href="#menu-toggle" id="menu-toggle"><i class="fa fa-bars" aria-hidden="true"></i></a></div><ul class="pull-right"><li id="gh-eyes-item" class="hidden-xs"><a href="https://github.com/typelevel/cats"><i class="fa fa-eye"></i><span>WATCH<span id="eyes" class="label label-default">--</span></span></a></li><li id="gh-stars-item" class="hidden-xs"><a href="https://github.com/typelevel/cats"><i class="fa fa-star-o"></i><span>STARS<span id="stars" class="label label-default">--</span></span></a></li><li><a href="#" onclick="shareSiteTwitter('Cats Lightweight, modular, and extensible library for functional programming');"><i class="fa fa-twitter"></i></a></li><li><a href="#" onclick="shareSiteFacebook('Cats Lightweight, modular, and extensible library for functional programming');"><i class="fa fa-facebook"></i></a></li><li><a href="#" onclick="shareSiteGoogle();"><i class="fa fa-google-plus"></i></a></li></ul></div></div></div></div><div id="content" data-github-owner="typelevel" data-github-repo="cats"><div class="content-wrapper"><section><h1 id="functor">Functor</h1>
<p><code class="highlighter-rouge">Functor</code> is a type class that abstracts over type constructors that can be <code class="highlighter-rouge">map</code>‘ed over. Examples of such
type constructors are <code class="highlighter-rouge">List</code>, <code class="highlighter-rouge">Option</code>, and <code class="highlighter-rouge">Future</code>.</p>

<div class="language-scala highlighter-rouge"><pre class="highlight"><code><span class="k">trait</span> <span class="nc">Functor</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]]</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">map</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">](</span><span class="n">fa</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">])(</span><span class="n">f</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="n">B</span><span class="o">)</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">B</span><span class="o">]</span>
<span class="o">}</span>

<span class="c1">// Example implementation for Option
</span><span class="k">implicit</span> <span class="k">val</span> <span class="n">functorForOption</span><span class="k">:</span> <span class="kt">Functor</span><span class="o">[</span><span class="kt">Option</span><span class="o">]</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Functor</span><span class="o">[</span><span class="kt">Option</span><span class="o">]</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">map</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">](</span><span class="n">fa</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">A</span><span class="o">])(</span><span class="n">f</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="n">B</span><span class="o">)</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">B</span><span class="o">]</span> <span class="k">=</span> <span class="n">fa</span> <span class="k">match</span> <span class="o">{</span>
    <span class="k">case</span> <span class="nc">None</span>    <span class="k">=&gt;</span> <span class="nc">None</span>
    <span class="k">case</span> <span class="nc">Some</span><span class="o">(</span><span class="n">a</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nc">Some</span><span class="o">(</span><span class="n">f</span><span class="o">(</span><span class="n">a</span><span class="o">))</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre>
</div>

<p>A <code class="highlighter-rouge">Functor</code> instance must obey two laws:</p>

<ul>
  <li>Composition: Mapping with <code class="highlighter-rouge">f</code> and then again with <code class="highlighter-rouge">g</code> is the same as mapping once with the composition of <code class="highlighter-rouge">f</code> and <code class="highlighter-rouge">g</code>
    <ul>
      <li><code class="highlighter-rouge">fa.map(f).map(g) = fa.map(f.andThen(g))</code></li>
    </ul>
  </li>
  <li>Identity: Mapping with the identity function is a no-op
    <ul>
      <li><code class="highlighter-rouge">fa.map(x =&gt; x) = fa</code></li>
    </ul>
  </li>
</ul>

<h2 id="a-different-view">A different view</h2>

<p>Another way of viewing a <code class="highlighter-rouge">Functor[F]</code> is that <code class="highlighter-rouge">F</code> allows the lifting of a pure function <code class="highlighter-rouge">A =&gt; B</code> into the effectful
function <code class="highlighter-rouge">F[A] =&gt; F[B]</code>. We can see this if we re-order the <code class="highlighter-rouge">map</code> signature above.</p>

<div class="language-scala highlighter-rouge"><pre class="highlight"><code><span class="k">trait</span> <span class="nc">Functor</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]]</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">map</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">](</span><span class="n">fa</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">])(</span><span class="n">f</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="n">B</span><span class="o">)</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">B</span><span class="o">]</span>

  <span class="k">def</span> <span class="n">lift</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">](</span><span class="n">f</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="n">B</span><span class="o">)</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=&gt;</span> <span class="n">F</span><span class="o">[</span><span class="kt">B</span><span class="o">]</span> <span class="k">=</span>
    <span class="n">fa</span> <span class="k">=&gt;</span> <span class="n">map</span><span class="o">(</span><span class="n">fa</span><span class="o">)(</span><span class="n">f</span><span class="o">)</span>
<span class="o">}</span>
</code></pre>
</div>

<h2 id="functors-for-effect-management">Functors for effect management</h2>

<p>The <code class="highlighter-rouge">F</code> in <code class="highlighter-rouge">Functor</code> is often referred to as an “effect” or “computational context.” Different effects will
abstract away different behaviors with respect to fundamental functions like <code class="highlighter-rouge">map</code>. For instance, <code class="highlighter-rouge">Option</code>’s effect
abstracts away potentially missing values, where <code class="highlighter-rouge">map</code> applies the function only in the <code class="highlighter-rouge">Some</code> case but
otherwise threads the <code class="highlighter-rouge">None</code> through.</p>

<p>Taking this view, we can view <code class="highlighter-rouge">Functor</code> as the ability to work with a <strong>single</strong> effect - we can apply a pure
function to a single effectful value without needing to “leave” the effect.</p>

<h2 id="functors-compose">Functors compose</h2>

<p>If you’ve ever found yourself working with nested data types such as <code class="highlighter-rouge">Option[List[A]]</code> or
<code class="highlighter-rouge">List[Either[String, Future[A]]]</code> and tried to <code class="highlighter-rouge">map</code> over it, you’ve most likely found yourself doing something
like <code class="highlighter-rouge">_.map(_.map(_.map(f)))</code>. As it turns out, <code class="highlighter-rouge">Functor</code>s compose, which means if <code class="highlighter-rouge">F</code> and <code class="highlighter-rouge">G</code> have
<code class="highlighter-rouge">Functor</code> instances, then so does <code class="highlighter-rouge">F[G[_]]</code>.</p>

<p>Such composition can be achieved via the <code class="highlighter-rouge">Functor#compose</code> method.</p>

<div class="language-scala highlighter-rouge"><pre class="highlight"><code><span class="k">import</span> <span class="nn">cats.Functor</span>
<span class="k">import</span> <span class="nn">cats.instances.list._</span>
<span class="k">import</span> <span class="nn">cats.instances.option._</span>
</code></pre>
</div>

<div class="language-scala highlighter-rouge"><pre class="highlight"><code><span class="k">val</span> <span class="n">listOption</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="nc">Some</span><span class="o">(</span><span class="mi">1</span><span class="o">),</span> <span class="nc">None</span><span class="o">,</span> <span class="nc">Some</span><span class="o">(</span><span class="mi">2</span><span class="o">))</span>
<span class="c1">// listOption: List[Option[Int]] = List(Some(1), None, Some(2))
</span>
<span class="c1">// Through Functor#compose
</span><span class="nc">Functor</span><span class="o">[</span><span class="kt">List</span><span class="o">].</span><span class="n">compose</span><span class="o">[</span><span class="kt">Option</span><span class="o">].</span><span class="n">map</span><span class="o">(</span><span class="n">listOption</span><span class="o">)(</span><span class="k">_</span> <span class="o">+</span> <span class="mi">1</span><span class="o">)</span>
<span class="c1">// res1: List[Option[Int]] = List(Some(2), None, Some(3))
</span></code></pre>
</div>

<p>This approach will allow us to use composition without wrapping the value in question, but can
introduce complications in more complex use cases. For example, if we need to call another function which
requires a <code class="highlighter-rouge">Functor</code> and we want to use the composed <code class="highlighter-rouge">Functor</code>, we would have to explicitly pass in the
composed instance during the function call or create a local implicit.</p>

<div class="language-scala highlighter-rouge"><pre class="highlight"><code><span class="k">def</span> <span class="n">needsFunctor</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span><span class="kt">:</span> <span class="kt">Functor</span>, <span class="kt">A</span><span class="o">](</span><span class="n">fa</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">Unit</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Functor</span><span class="o">[</span><span class="kt">F</span><span class="o">].</span><span class="n">map</span><span class="o">(</span><span class="n">fa</span><span class="o">)(</span><span class="k">_</span> <span class="k">=&gt;</span> <span class="o">())</span>

<span class="k">def</span> <span class="n">foo</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Option</span><span class="o">[</span><span class="kt">Unit</span><span class="o">]]</span> <span class="k">=</span> <span class="o">{</span>
  <span class="k">val</span> <span class="n">listOptionFunctor</span> <span class="k">=</span> <span class="nc">Functor</span><span class="o">[</span><span class="kt">List</span><span class="o">].</span><span class="n">compose</span><span class="o">[</span><span class="kt">Option</span><span class="o">]</span>
  <span class="k">type</span> <span class="kt">ListOption</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=</span> <span class="nc">List</span><span class="o">[</span><span class="kt">Option</span><span class="o">[</span><span class="kt">A</span><span class="o">]]</span>
  <span class="n">needsFunctor</span><span class="o">[</span><span class="kt">ListOption</span>, <span class="kt">Int</span><span class="o">](</span><span class="n">listOption</span><span class="o">)(</span><span class="n">listOptionFunctor</span><span class="o">)</span>
<span class="o">}</span>
</code></pre>
</div>

<p>We can make this nicer at the cost of boxing with the <code class="highlighter-rouge">Nested</code> data type.</p>

<div class="language-scala highlighter-rouge"><pre class="highlight"><code><span class="k">import</span> <span class="nn">cats.data.Nested</span>
<span class="k">import</span> <span class="nn">cats.syntax.functor._</span>
</code></pre>
</div>

<div class="language-scala highlighter-rouge"><pre class="highlight"><code><span class="k">val</span> <span class="n">nested</span><span class="k">:</span> <span class="kt">Nested</span><span class="o">[</span><span class="kt">List</span>, <span class="kt">Option</span>, <span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Nested</span><span class="o">(</span><span class="n">listOption</span><span class="o">)</span>
<span class="c1">// nested: cats.data.Nested[List,Option,Int] = Nested(List(Some(1), None, Some(2)))
</span>
<span class="n">nested</span><span class="o">.</span><span class="n">map</span><span class="o">(</span><span class="k">_</span> <span class="o">+</span> <span class="mi">1</span><span class="o">)</span>
<span class="c1">// res2: cats.data.Nested[List,Option,Int] = Nested(List(Some(2), None, Some(3)))
</span></code></pre>
</div>

<p>The <code class="highlighter-rouge">Nested</code> approach, being a distinct type from its constituents, will resolve the usual way modulo
possible <a href="https://issues.scala-lang.org/browse/SI-2712" title="SI-2712: implement higher-order unification for type constructor inference">SI-2712</a> issues (which can be addressed through <a href="https://github.com/fiadliel/sbt-partial-unification" title="A sbt plugin for enabling partial unification">partial unification</a>),
but requires syntactic and runtime overhead from wrapping and unwrapping.</p>

</section></div></div></div></div><script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/1.11.3/jquery.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.3.7/js/bootstrap.min.js"></script><script src="/cats/highlight/highlight.pack.js"></script><script>hljs.configure({
languages:['scala','java','bash']
});
hljs.initHighlighting();
             </script><script>((window.gitter = {}).chat = {}).options = {
room: 'typelevel/cats'};</script><script src="https://sidecar.gitter.im/dist/sidecar.v1.js"></script><script src="/cats/js/main.js"></script></body></html>