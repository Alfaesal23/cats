<!DOCTYPE html><html><head><title>Cats: Type Classes</title><meta charset="utf-8" /><meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" /><meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="author" content="Cats contributors" /><meta name="description" content="Lightweight, modular, and extensible library for functional programming" /><meta name="og:image" content="/cats/img/poster.png" /><meta name="image" property="og:image" content="/cats/img/poster.png" /><meta name="og:title" content="Cats: Type Classes" /><meta name="title" property="og:title" content="Cats: Type Classes" /><meta name="og:site_name" content="Cats" /><meta name="og:url" content="http://typelevel.org/cats/" /><meta name="og:type" content="website" /><meta name="og:description" content="Lightweight, modular, and extensible library for functional programming" /><link rel="icon" type="image/png" href="/cats/img/favicon.png" /><meta name="twitter:title" content="Cats: Type Classes" /><meta name="twitter:image" content="/cats/img/poster.png" /><meta name="twitter:description" content="Lightweight, modular, and extensible library for functional programming" /><meta name="twitter:card" content="summary_large_image" /><link rel="icon" type="image/png" sizes="16x16" href="/cats/img/favicon16x16.png" /><link rel="icon" type="image/png" sizes="24x24" href="/cats/img/favicon24x24.png" /><link rel="icon" type="image/png" sizes="32x32" href="/cats/img/favicon32x32.png" /><link rel="icon" type="image/png" sizes="48x48" href="/cats/img/favicon48x48.png" /><link rel="icon" type="image/png" sizes="57x57" href="/cats/img/favicon57x57.png" /><link rel="icon" type="image/png" sizes="60x60" href="/cats/img/favicon60x60.png" /><link rel="icon" type="image/png" sizes="64x64" href="/cats/img/favicon64x64.png" /><link rel="icon" type="image/png" sizes="70x70" href="/cats/img/favicon70x70.png" /><link rel="icon" type="image/png" sizes="72x72" href="/cats/img/favicon72x72.png" /><link rel="icon" type="image/png" sizes="76x76" href="/cats/img/favicon76x76.png" /><link rel="icon" type="image/png" sizes="96x96" href="/cats/img/favicon96x96.png" /><link rel="icon" type="image/png" sizes="114x114" href="/cats/img/favicon114x114.png" /><link rel="icon" type="image/png" sizes="120x120" href="/cats/img/favicon120x120.png" /><link rel="icon" type="image/png" sizes="128x128" href="/cats/img/favicon128x128.png" /><link rel="icon" type="image/png" sizes="144x144" href="/cats/img/favicon144x144.png" /><link rel="icon" type="image/png" sizes="150x150" href="/cats/img/favicon150x150.png" /><link rel="icon" type="image/png" sizes="152x152" href="/cats/img/favicon152x152.png" /><link rel="icon" type="image/png" sizes="196x196" href="/cats/img/favicon196x196.png" /><link rel="icon" type="image/png" sizes="310x310" href="/cats/img/favicon310x310.png" /><link rel="icon" type="image/png" sizes="310x150" href="/cats/img/favicon310x150.png" /><link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css" /><link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css" /><link rel="stylesheet" href="/cats/highlight/styles/atom-one-light.css" /><link rel="stylesheet" href="/cats/css/pattern-style.css" /></head><body class="docs"><div id="wrapper"><div id="sidebar-wrapper"><ul id="sidebar" class="sidebar-nav"><li class="sidebar-brand"><a href="/cats/" class="brand"><div class="brand-wrapper"><span>Cats</span></div></a></li><li><a href="/cats/typeclasses/alternative.html" class="">Alternative</a></li><li><a href="/cats/typeclasses/applicative.html" class="">Applicative</a></li><li><a href="/cats/typeclasses/applicativemonaderror.html" class="">Applicative Error</a></li><li><a href="/cats/typeclasses/applicativetraverse.html" class="">Applicative and Traversable Functors</a></li><li><a href="/cats/typeclasses/arrow.html" class="">Arrow</a></li><li><a href="/cats/typeclasses/arrowchoice.html" class="">Arrow Choice</a></li><li><a href="/cats/typeclasses/bifunctor.html" class="">Bifunctor</a></li><li><a href="/cats/typeclasses/comonad.html" class="">Comonad</a></li><li><a href="/cats/typeclasses/contravariant.html" class="">Contravariant</a></li><li><a href="/cats/typeclasses/contravariantmonoidal.html" class="">Contravariant Monoidal</a></li><li><a href="/cats/typeclasses/eq.html" class="">Eq</a></li><li><a href="/cats/typeclasses/foldable.html" class="">Foldable</a></li><li><a href="/cats/typeclasses/functor.html" class="">Functor</a></li><li><a href="/cats/typeclasses/invariant.html" class="">Invariant</a></li><li><a href="/cats/typeclasses/invariantmonoidal.html" class="">InvariantMonoidal</a></li><li><a href="/cats/typeclasses/lawtesting.html" class="">Law Testing</a></li><li><a href="/cats/typeclasses/monad.html" class="">Monad</a></li><li><a href="/cats/typeclasses/monoid.html" class="">Monoid</a></li><li><a href="/cats/typeclasses/monoidk.html" class="">MonoidK</a></li><li><a href="/cats/typeclasses/nonemptytraverse.html" class="">NonEmptyTraverse</a></li><li><a href="/cats/typeclasses/parallel.html" class="">Parallel</a></li><li><a href="/cats/typeclasses/reducible.html" class="">Reducible</a></li><li><a href="/cats/typeclasses/semigroup.html" class="">Semigroup</a></li><li><a href="/cats/typeclasses/semigroupk.html" class="">SemigroupK</a></li><li><a href="/cats/typeclasses/show.html" class="">Show</a></li><li><a href="/cats/typeclasses/traverse.html" class="">Traverse</a></li><li><a href="/cats/typeclasses.html" class=" active ">Type Classes</a></li></ul></div><div id="page-content-wrapper"><div class="nav"><div class="container-fluid"><div class="row"><div class="col-lg-12"><div class="action-menu pull-left clearfix"><a href="#menu-toggle" id="menu-toggle"><i class="fa fa-bars" aria-hidden="true"></i></a></div><ul class="pull-right"><li class="search-nav hidden-xs hidden-sm"><div id="search-dropdown"><label><i class="fa fa-search"></i>Search</label><input id="search-bar" type="text" placeholder="Enter keywords here..." onclick="displayToggleSearch(event)" /><ul id="search-dropdown-content" class="dropdown dropdown-content"></ul></div></li><li id="gh-eyes-item" class="hidden-xs to-uppercase"><a href="https://github.com/typelevel/cats" target="_blank" rel="noopener noreferrer"><i class="fa fa-eye"></i><span>Watchers<span id="eyes" class="label label-default">--</span></span></a></li><li id="gh-stars-item" class="hidden-xs to-uppercase"><a href="https://github.com/typelevel/cats" target="_blank" rel="noopener noreferrer"><i class="fa fa-star-o"></i><span>Stars<span id="stars" class="label label-default">--</span></span></a></li><li><a href="#" onclick="shareSiteTwitter('Cats Lightweight, modular, and extensible library for functional programming');"><i class="fa fa-twitter"></i></a></li><li><a href="#" onclick="shareSiteFacebook('Cats Lightweight, modular, and extensible library for functional programming');"><i class="fa fa-facebook"></i></a></li></ul></div></div></div></div><div id="content" data-github-owner="typelevel" data-github-repo="cats"><div class="content-wrapper"><section><h1 id="type-classes">Type classes</h1>
<p>Type classes are a powerful tool used in functional programming to enable ad-hoc polymorphism, more commonly
known as overloading. Where many object-oriented languages leverage subtyping for polymorphic code, functional
programming tends towards a combination of parametric polymorphism (think type parameters, like Java generics)
and ad-hoc polymorphism.</p>

<h2 id="example-collapsing-a-list">Example: collapsing a list</h2>
<p>The following code snippets show code that sums a list of integers, concatenates a list of strings, and unions a list
of sets.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">sumInts</span><span class="o">(</span><span class="n">list</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Int</span><span class="o">])</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="nv">list</span><span class="o">.</span><span class="py">foldRight</span><span class="o">(</span><span class="mi">0</span><span class="o">)(</span><span class="k">_</span> <span class="o">+</span> <span class="k">_</span><span class="o">)</span>

<span class="k">def</span> <span class="nf">concatStrings</span><span class="o">(</span><span class="n">list</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">String</span><span class="o">])</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="nv">list</span><span class="o">.</span><span class="py">foldRight</span><span class="o">(</span><span class="s">""</span><span class="o">)(</span><span class="k">_</span> <span class="o">++</span> <span class="k">_</span><span class="o">)</span>

<span class="k">def</span> <span class="nf">unionSets</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">list</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Set</span><span class="o">[</span><span class="kt">A</span><span class="o">]])</span><span class="k">:</span> <span class="kt">Set</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=</span> <span class="nv">list</span><span class="o">.</span><span class="py">foldRight</span><span class="o">(</span><span class="nv">Set</span><span class="o">.</span><span class="py">empty</span><span class="o">[</span><span class="kt">A</span><span class="o">])(</span><span class="k">_</span> <span class="n">union</span> <span class="k">_</span><span class="o">)</span>
</code></pre></div></div>

<p>All of these follow the same pattern: an initial value (0, empty string, empty set) and a combining function
(<code class="language-plaintext highlighter-rouge">+</code>, <code class="language-plaintext highlighter-rouge">++</code>, <code class="language-plaintext highlighter-rouge">union</code>). We’d like to abstract over this so we can write the function once instead of once for every type
so we pull out the necessary pieces into an interface.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">trait</span> <span class="nc">Monoid</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="o">{</span>
  <span class="k">def</span> <span class="nf">empty</span><span class="k">:</span> <span class="kt">A</span>
  <span class="k">def</span> <span class="nf">combine</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">A</span><span class="o">,</span> <span class="n">y</span><span class="k">:</span> <span class="kt">A</span><span class="o">)</span><span class="k">:</span> <span class="kt">A</span>
<span class="o">}</span>

<span class="c1">// Implementation for Int</span>
<span class="k">val</span> <span class="nv">intAdditionMonoid</span><span class="k">:</span> <span class="kt">Monoid</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Monoid</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="o">{</span>
  <span class="k">def</span> <span class="nf">empty</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">0</span>
  <span class="k">def</span> <span class="nf">combine</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">y</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span>
<span class="o">}</span>
</code></pre></div></div>

<p>The name <code class="language-plaintext highlighter-rouge">Monoid</code> is taken from abstract algebra which specifies precisely this kind of structure.</p>

<p>We can now write the functions above against this interface.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">combineAll</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">list</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">A</span><span class="o">],</span> <span class="n">m</span><span class="k">:</span> <span class="kt">Monoid</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=</span> <span class="nv">list</span><span class="o">.</span><span class="py">foldRight</span><span class="o">(</span><span class="nv">m</span><span class="o">.</span><span class="py">empty</span><span class="o">)(</span><span class="nv">m</span><span class="o">.</span><span class="py">combine</span><span class="o">)</span>
</code></pre></div></div>

<h2 id="type-classes-vs-subtyping">Type classes vs. subtyping</h2>
<p>The definition above takes an actual monoid argument instead of doing the usual object-oriented practice of using
subtype constraints.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Subtyping</span>
<span class="k">def</span> <span class="nf">combineAll</span><span class="o">[</span><span class="kt">A</span> <span class="k">&lt;:</span> <span class="kt">Monoid</span><span class="o">[</span><span class="kt">A</span><span class="o">]](</span><span class="n">list</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=</span> <span class="o">???</span>
</code></pre></div></div>

<p>This has a subtle difference with the earlier explicit example. In order to seed the <code class="language-plaintext highlighter-rouge">foldRight</code> with the empty value,
we need to get a hold of it given only the type <code class="language-plaintext highlighter-rouge">A</code>. Taking <code class="language-plaintext highlighter-rouge">Monoid[A]</code> as an argument gives us this by calling the
appropriate <code class="language-plaintext highlighter-rouge">empty</code> method on it. With the subtype example, the <code class="language-plaintext highlighter-rouge">empty</code> method would be on a <strong>value</strong> of type
<code class="language-plaintext highlighter-rouge">Monoid[A]</code> itself, which we are only getting from the <code class="language-plaintext highlighter-rouge">list</code> argument. If <code class="language-plaintext highlighter-rouge">list</code> is empty, we have no values to work
with and therefore can’t get the empty value. Not to mention the oddity of getting a constant value from a non-static
object.</p>

<hr />

<p>For another motivating difference, consider the simple pair type.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">final</span> <span class="k">case</span> <span class="k">class</span> <span class="nc">Pair</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">](</span><span class="n">first</span><span class="k">:</span> <span class="kt">A</span><span class="o">,</span> <span class="n">second</span><span class="k">:</span> <span class="kt">B</span><span class="o">)</span>
</code></pre></div></div>

<p>Defining a <code class="language-plaintext highlighter-rouge">Monoid[Pair[A, B]]</code> depends on the ability to define a <code class="language-plaintext highlighter-rouge">Monoid[A]</code> and <code class="language-plaintext highlighter-rouge">Monoid[B]</code>, where the definition
is point-wise, i.e. the first element of the first pair combines with the first element of the second pair and the second element of the first pair combines with the second element of the second pair. With subtyping such a constraint would be encoded as something like</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">final</span> <span class="k">case</span> <span class="k">class</span> <span class="nc">Pair</span><span class="o">[</span><span class="kt">A</span> <span class="k">&lt;:</span> <span class="kt">Monoid</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span>, <span class="kt">B</span> <span class="k">&lt;:</span> <span class="kt">Monoid</span><span class="o">[</span><span class="kt">B</span><span class="o">]](</span><span class="n">first</span><span class="k">:</span> <span class="kt">A</span><span class="o">,</span> <span class="n">second</span><span class="k">:</span> <span class="kt">B</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">Monoid</span><span class="o">[</span><span class="kt">Pair</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">]]</span> <span class="o">{</span>
  <span class="k">def</span> <span class="nf">empty</span><span class="k">:</span> <span class="kt">Pair</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">]</span> <span class="k">=</span> <span class="o">???</span>

  <span class="k">def</span> <span class="nf">combine</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Pair</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">],</span> <span class="n">y</span><span class="k">:</span> <span class="kt">Pair</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">])</span><span class="k">:</span> <span class="kt">Pair</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">]</span> <span class="k">=</span> <span class="o">???</span>
<span class="o">}</span>
</code></pre></div></div>

<p>Not only is the type signature of <code class="language-plaintext highlighter-rouge">Pair</code> now messy but it also forces all instances of <code class="language-plaintext highlighter-rouge">Pair</code> to have a <code class="language-plaintext highlighter-rouge">Monoid</code>
instance, whereas <code class="language-plaintext highlighter-rouge">Pair</code> should be able to carry any types it wants and if the types happens to have a
<code class="language-plaintext highlighter-rouge">Monoid</code> instance then so would it. We could try bubbling down the constraint into the methods themselves.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">final</span> <span class="k">case</span> <span class="k">class</span> <span class="nc">Pair</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">](</span><span class="n">first</span><span class="k">:</span> <span class="kt">A</span><span class="o">,</span> <span class="n">second</span><span class="k">:</span> <span class="kt">B</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">Monoid</span><span class="o">[</span><span class="kt">Pair</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">]]</span> <span class="o">{</span>
  <span class="k">def</span> <span class="nf">empty</span><span class="o">(</span><span class="k">implicit</span> <span class="n">eva</span><span class="k">:</span> <span class="kt">A</span> <span class="k">&lt;:</span><span class="kt">&lt;</span> <span class="kt">Monoid</span><span class="o">[</span><span class="kt">A</span><span class="o">],</span> <span class="n">evb</span><span class="k">:</span> <span class="kt">B</span> <span class="k">&lt;:</span><span class="kt">&lt;</span> <span class="kt">Monoid</span><span class="o">[</span><span class="kt">B</span><span class="o">])</span><span class="k">:</span> <span class="kt">Pair</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">]</span> <span class="k">=</span> <span class="o">???</span>

  <span class="k">def</span> <span class="nf">combine</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Pair</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">],</span> <span class="n">y</span><span class="k">:</span> <span class="kt">Pair</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">])(</span><span class="k">implicit</span> <span class="n">eva</span><span class="k">:</span> <span class="kt">A</span> <span class="k">&lt;:</span><span class="kt">&lt;</span> <span class="kt">Monoid</span><span class="o">[</span><span class="kt">A</span><span class="o">],</span> <span class="n">evb</span><span class="k">:</span> <span class="kt">B</span> <span class="k">&lt;:</span><span class="kt">&lt;</span> <span class="kt">Monoid</span><span class="o">[</span><span class="kt">B</span><span class="o">])</span><span class="k">:</span> <span class="kt">Pair</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">]</span> <span class="k">=</span> <span class="o">???</span>
<span class="o">}</span>
<span class="c1">// error: class Pair needs to be abstract, since:</span>
<span class="c1">// it has 2 unimplemented members.</span>
<span class="c1">// /** As seen from class Pair, the missing signatures are as follows.</span>
<span class="c1">//  *  For convenience, these are usable as stub implementations.</span>
<span class="c1">//  */</span>
<span class="c1">//   def combine(x: Pair[A,B],y: Pair[A,B]): Pair[A,B] = ???</span>
<span class="c1">//   def empty: Pair[A,B] = ???</span>
<span class="c1">// </span>
<span class="c1">// final case class Pair[A, B](first: A, second: B) extends Monoid[Pair[A, B]] {</span>
<span class="c1">// ^</span>
</code></pre></div></div>

<p>But now these don’t conform to the interface of <code class="language-plaintext highlighter-rouge">Monoid</code> due to the implicit constraints.</p>

<h3 id="implicit-derivation">Implicit derivation</h3>

<p>Note that a <code class="language-plaintext highlighter-rouge">Monoid[Pair[A, B]]</code> is derivable given <code class="language-plaintext highlighter-rouge">Monoid[A]</code> and <code class="language-plaintext highlighter-rouge">Monoid[B]</code>:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">final</span> <span class="k">case</span> <span class="k">class</span> <span class="nc">Pair</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">](</span><span class="n">first</span><span class="k">:</span> <span class="kt">A</span><span class="o">,</span> <span class="n">second</span><span class="k">:</span> <span class="kt">B</span><span class="o">)</span>

<span class="k">def</span> <span class="nf">deriveMonoidPair</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">](</span><span class="n">A</span><span class="k">:</span> <span class="kt">Monoid</span><span class="o">[</span><span class="kt">A</span><span class="o">],</span> <span class="n">B</span><span class="k">:</span> <span class="kt">Monoid</span><span class="o">[</span><span class="kt">B</span><span class="o">])</span><span class="k">:</span> <span class="kt">Monoid</span><span class="o">[</span><span class="kt">Pair</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">]]</span> <span class="k">=</span>
  <span class="k">new</span> <span class="nc">Monoid</span><span class="o">[</span><span class="kt">Pair</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">]]</span> <span class="o">{</span>
    <span class="k">def</span> <span class="nf">empty</span><span class="k">:</span> <span class="kt">Pair</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Pair</span><span class="o">(</span><span class="nv">A</span><span class="o">.</span><span class="py">empty</span><span class="o">,</span> <span class="nv">B</span><span class="o">.</span><span class="py">empty</span><span class="o">)</span>

    <span class="k">def</span> <span class="nf">combine</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Pair</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">],</span> <span class="n">y</span><span class="k">:</span> <span class="kt">Pair</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">])</span><span class="k">:</span> <span class="kt">Pair</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">]</span> <span class="k">=</span>
      <span class="nc">Pair</span><span class="o">(</span><span class="nv">A</span><span class="o">.</span><span class="py">combine</span><span class="o">(</span><span class="nv">x</span><span class="o">.</span><span class="py">first</span><span class="o">,</span> <span class="nv">y</span><span class="o">.</span><span class="py">first</span><span class="o">),</span> <span class="nv">B</span><span class="o">.</span><span class="py">combine</span><span class="o">(</span><span class="nv">x</span><span class="o">.</span><span class="py">second</span><span class="o">,</span> <span class="nv">y</span><span class="o">.</span><span class="py">second</span><span class="o">))</span>
  <span class="o">}</span>
</code></pre></div></div>

<p>One of the most powerful features of type classes is the ability to do this kind of derivation automatically.
We can do this through Scala’s implicit mechanism.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">cats.Monoid</span>

<span class="k">object</span> <span class="nc">Demo</span> <span class="o">{</span> 
  <span class="k">final</span> <span class="k">case</span> <span class="k">class</span> <span class="nc">Pair</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">](</span><span class="n">first</span><span class="k">:</span> <span class="kt">A</span><span class="o">,</span> <span class="n">second</span><span class="k">:</span> <span class="kt">B</span><span class="o">)</span>

  <span class="k">object</span> <span class="nc">Pair</span> <span class="o">{</span>
    <span class="k">implicit</span> <span class="k">def</span> <span class="nf">tuple2Instance</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">](</span><span class="k">implicit</span> <span class="n">A</span><span class="k">:</span> <span class="kt">Monoid</span><span class="o">[</span><span class="kt">A</span><span class="o">],</span> <span class="n">B</span><span class="k">:</span> <span class="kt">Monoid</span><span class="o">[</span><span class="kt">B</span><span class="o">])</span><span class="k">:</span> <span class="kt">Monoid</span><span class="o">[</span><span class="kt">Pair</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">]]</span> <span class="k">=</span>
      <span class="k">new</span> <span class="nc">Monoid</span><span class="o">[</span><span class="kt">Pair</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">]]</span> <span class="o">{</span>
        <span class="k">def</span> <span class="nf">empty</span><span class="k">:</span> <span class="kt">Pair</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Pair</span><span class="o">(</span><span class="nv">A</span><span class="o">.</span><span class="py">empty</span><span class="o">,</span> <span class="nv">B</span><span class="o">.</span><span class="py">empty</span><span class="o">)</span>

        <span class="k">def</span> <span class="nf">combine</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Pair</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">],</span> <span class="n">y</span><span class="k">:</span> <span class="kt">Pair</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">])</span><span class="k">:</span> <span class="kt">Pair</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">]</span> <span class="k">=</span>
          <span class="nc">Pair</span><span class="o">(</span><span class="nv">A</span><span class="o">.</span><span class="py">combine</span><span class="o">(</span><span class="nv">x</span><span class="o">.</span><span class="py">first</span><span class="o">,</span> <span class="nv">y</span><span class="o">.</span><span class="py">first</span><span class="o">),</span> <span class="nv">B</span><span class="o">.</span><span class="py">combine</span><span class="o">(</span><span class="nv">x</span><span class="o">.</span><span class="py">second</span><span class="o">,</span> <span class="nv">y</span><span class="o">.</span><span class="py">second</span><span class="o">))</span>
      <span class="o">}</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>We also change any functions that have a <code class="language-plaintext highlighter-rouge">Monoid</code> constraint on the type parameter to take the argument implicitly,
and any instances of the type class to be implicit.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">implicit</span> <span class="k">val</span> <span class="nv">intAdditionMonoid</span><span class="k">:</span> <span class="kt">Monoid</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Monoid</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="o">{</span>
  <span class="k">def</span> <span class="nf">empty</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">0</span>
  <span class="k">def</span> <span class="nf">combine</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">y</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span>
<span class="o">}</span>

<span class="k">def</span> <span class="nf">combineAll</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">list</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">A</span><span class="o">])(</span><span class="k">implicit</span> <span class="n">A</span><span class="k">:</span> <span class="kt">Monoid</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=</span> <span class="nv">list</span><span class="o">.</span><span class="py">foldRight</span><span class="o">(</span><span class="nv">A</span><span class="o">.</span><span class="py">empty</span><span class="o">)(</span><span class="nv">A</span><span class="o">.</span><span class="py">combine</span><span class="o">)</span>
</code></pre></div></div>

<p>Now we can also <code class="language-plaintext highlighter-rouge">combineAll</code> a list of <code class="language-plaintext highlighter-rouge">Pair</code>s as long as <code class="language-plaintext highlighter-rouge">Pair</code>’s type parameters themselves have <code class="language-plaintext highlighter-rouge">Monoid</code>
instances.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">implicit</span> <span class="k">val</span> <span class="nv">stringMonoid</span><span class="k">:</span> <span class="kt">Monoid</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Monoid</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span> <span class="o">{</span>
  <span class="k">def</span> <span class="nf">empty</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="s">""</span>
  <span class="k">def</span> <span class="nf">combine</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span> <span class="n">y</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="n">x</span> <span class="o">++</span> <span class="n">y</span>
<span class="o">}</span>
</code></pre></div></div>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">Demo.</span><span class="o">{</span><span class="nc">Pair</span> <span class="k">=&gt;</span> <span class="nc">Paired</span><span class="o">}</span>

<span class="nf">combineAll</span><span class="o">(</span><span class="nc">List</span><span class="o">(</span><span class="nc">Paired</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="s">"hello"</span><span class="o">),</span> <span class="nc">Paired</span><span class="o">(</span><span class="mi">2</span><span class="o">,</span> <span class="s">" "</span><span class="o">),</span> <span class="nc">Paired</span><span class="o">(</span><span class="mi">3</span><span class="o">,</span> <span class="s">"world"</span><span class="o">)))</span>
<span class="c1">// res2: Demo.Pair[Int, String] = Pair(6, "hello world")</span>
</code></pre></div></div>

<h2 id="a-note-on-syntax">A note on syntax</h2>
<p>In many cases, including the <code class="language-plaintext highlighter-rouge">combineAll</code> function above, the implicit arguments can be written with syntactic sugar.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">combineAll</span><span class="o">[</span><span class="kt">A</span> <span class="kt">:</span> <span class="kt">Monoid</span><span class="o">](</span><span class="n">list</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=</span> <span class="o">???</span>
</code></pre></div></div>

<p>While nicer to read as a user, it comes at a cost for the implementer.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">cats.Monoid</span>

<span class="c1">// Defined in the standard library, shown for illustration purposes</span>
<span class="c1">// Implicitly looks in implicit scope for a value of type `A` and just hands it back</span>
<span class="k">def</span> <span class="nf">implicitly</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="k">implicit</span> <span class="n">ev</span><span class="k">:</span> <span class="kt">A</span><span class="o">)</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=</span> <span class="n">ev</span>

<span class="k">def</span> <span class="nf">combineAll</span><span class="o">[</span><span class="kt">A</span> <span class="kt">:</span> <span class="kt">Monoid</span><span class="o">](</span><span class="n">list</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=</span>
  <span class="nv">list</span><span class="o">.</span><span class="py">foldRight</span><span class="o">(</span><span class="n">implicitly</span><span class="o">[</span><span class="kt">Monoid</span><span class="o">[</span><span class="kt">A</span><span class="o">]].</span><span class="py">empty</span><span class="o">)(</span><span class="n">implicitly</span><span class="o">[</span><span class="kt">Monoid</span><span class="o">[</span><span class="kt">A</span><span class="o">]].</span><span class="py">combine</span><span class="o">)</span>
</code></pre></div></div>

<p>For this reason, many libraries that provide type classes provide a utility method on the companion object of the type
class, usually under the name <code class="language-plaintext highlighter-rouge">apply</code>, that skirts the need to call <code class="language-plaintext highlighter-rouge">implicitly</code> everywhere.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">object</span> <span class="nc">Monoid</span> <span class="o">{</span>
  <span class="k">def</span> <span class="nf">apply</span><span class="o">[</span><span class="kt">A</span> <span class="kt">:</span> <span class="kt">Monoid</span><span class="o">]</span><span class="k">:</span> <span class="kt">Monoid</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=</span> <span class="n">implicitly</span><span class="o">[</span><span class="kt">Monoid</span><span class="o">[</span><span class="kt">A</span><span class="o">]]</span>
<span class="o">}</span>

<span class="k">def</span> <span class="nf">combineAll</span><span class="o">[</span><span class="kt">A</span> <span class="kt">:</span> <span class="kt">Monoid</span><span class="o">](</span><span class="n">list</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=</span>
  <span class="nv">list</span><span class="o">.</span><span class="py">foldRight</span><span class="o">(</span><span class="nc">Monoid</span><span class="o">[</span><span class="kt">A</span><span class="o">].</span><span class="py">empty</span><span class="o">)(</span><span class="nc">Monoid</span><span class="o">[</span><span class="kt">A</span><span class="o">].</span><span class="py">combine</span><span class="o">)</span>
</code></pre></div></div>

<p>Cats uses <a href="https://github.com/typelevel/simulacrum" title="First class syntax support for type classes in Scala">simulacrum</a> for defining type classes which will auto-generate such an <code class="language-plaintext highlighter-rouge">apply</code> method.</p>

<h1 id="laws">Laws</h1>

<p>Conceptually, all type classes come with laws. These laws constrain implementations for a given
type and can be exploited and used to reason about generic code.</p>

<p>For instance, the <code class="language-plaintext highlighter-rouge">Monoid</code> type class requires that
<code class="language-plaintext highlighter-rouge">combine</code> be associative and <code class="language-plaintext highlighter-rouge">empty</code> be an identity element for <code class="language-plaintext highlighter-rouge">combine</code>. That means the following
equalities should hold for any choice of <code class="language-plaintext highlighter-rouge">x</code>, <code class="language-plaintext highlighter-rouge">y</code>, and <code class="language-plaintext highlighter-rouge">z</code>.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>combine(x, combine(y, z)) = combine(combine(x, y), z)
combine(x, id) = combine(id, x) = x
</code></pre></div></div>

<p>With these laws in place, functions parametrized over a <code class="language-plaintext highlighter-rouge">Monoid</code> can leverage them for say, performance
reasons. A function that collapses a <code class="language-plaintext highlighter-rouge">List[A]</code> into a single <code class="language-plaintext highlighter-rouge">A</code> can do so with <code class="language-plaintext highlighter-rouge">foldLeft</code> or
<code class="language-plaintext highlighter-rouge">foldRight</code> since <code class="language-plaintext highlighter-rouge">combine</code> is assumed to be associative, or it can break apart the list into smaller
lists and collapse in parallel, such as</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="nv">list</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">5</span><span class="o">)</span>
<span class="nf">val</span> <span class="o">(</span><span class="n">left</span><span class="o">,</span> <span class="n">right</span><span class="o">)</span> <span class="k">=</span> <span class="nv">list</span><span class="o">.</span><span class="py">splitAt</span><span class="o">(</span><span class="mi">2</span><span class="o">)</span>
</code></pre></div></div>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Imagine the following two operations run in parallel</span>
<span class="k">val</span> <span class="nv">sumLeft</span> <span class="k">=</span> <span class="nf">combineAll</span><span class="o">(</span><span class="n">left</span><span class="o">)</span>
<span class="c1">// sumLeft: Int = 3</span>
<span class="k">val</span> <span class="nv">sumRight</span> <span class="k">=</span> <span class="nf">combineAll</span><span class="o">(</span><span class="n">right</span><span class="o">)</span>
<span class="c1">// sumRight: Int = 12</span>

<span class="c1">// Now gather the results</span>
<span class="k">val</span> <span class="nv">result</span> <span class="k">=</span> <span class="nc">Monoid</span><span class="o">[</span><span class="kt">Int</span><span class="o">].</span><span class="py">combine</span><span class="o">(</span><span class="n">sumLeft</span><span class="o">,</span> <span class="n">sumRight</span><span class="o">)</span>
<span class="c1">// result: Int = 15</span>
</code></pre></div></div>

<p>Cats provides laws for type classes via the <code class="language-plaintext highlighter-rouge">kernel-laws</code> and <code class="language-plaintext highlighter-rouge">laws</code> modules which makes law checking
type class instances easy.</p>

<p>You can find out more about law testing <a href="typeclasses/lawtesting.html">here</a>.</p>

<h2 id="type-classes-in-cats">Type classes in Cats</h2>

<p><img src="https://cdn.rawgit.com/tpolecat/cats-infographic/master/cats.svg" alt="infographic" style="width: 100%;" />
From <a href="https://github.com/tpolecat/cats-infographic">cats-infographic by @tpolecat</a>.</p>

<h2 id="incomplete-type-class-instances-in-cats">Incomplete type class instances in cats</h2>

<p>Originally from <a href="https://gist.github.com/alexknvl/d63508ddb6a728015ace53cb70a1fd5d">@alexknvl</a></p>

<table>
  <thead>
    <tr>
      <th>Type</th>
      <th style="text-align: center">Functor</th>
      <th style="text-align: center">Apply</th>
      <th style="text-align: center">Applicative</th>
      <th style="text-align: center">Monad</th>
      <th style="text-align: center">MonoidK</th>
      <th style="text-align: center">ApplicativeError</th>
      <th style="text-align: center">MonadError</th>
      <th style="text-align: center">CoflatMap</th>
      <th style="text-align: center">Comonad</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Id[A]</td>
      <td style="text-align: center">✔</td>
      <td style="text-align: center">✔</td>
      <td style="text-align: center">✔</td>
      <td style="text-align: center">✔</td>
      <td style="text-align: center">✗</td>
      <td style="text-align: center">✗</td>
      <td style="text-align: center">✗</td>
      <td style="text-align: center">✔</td>
      <td style="text-align: center">✔</td>
    </tr>
    <tr>
      <td>Eval[A]</td>
      <td style="text-align: center">✔</td>
      <td style="text-align: center">✔</td>
      <td style="text-align: center">✔</td>
      <td style="text-align: center">✔</td>
      <td style="text-align: center">✗</td>
      <td style="text-align: center">✗</td>
      <td style="text-align: center">✗</td>
      <td style="text-align: center">✔</td>
      <td style="text-align: center">✔</td>
    </tr>
    <tr>
      <td>Option[A]</td>
      <td style="text-align: center">✔</td>
      <td style="text-align: center">✔</td>
      <td style="text-align: center">✔</td>
      <td style="text-align: center">✔</td>
      <td style="text-align: center">✔</td>
      <td style="text-align: center">✔</td>
      <td style="text-align: center">✔</td>
      <td style="text-align: center">✔</td>
      <td style="text-align: center">✗</td>
    </tr>
    <tr>
      <td>Const[K, A]</td>
      <td style="text-align: center">✔</td>
      <td style="text-align: center">✔ (<code class="language-plaintext highlighter-rouge">K:Monoid</code>)</td>
      <td style="text-align: center">✔</td>
      <td style="text-align: center">✗</td>
      <td style="text-align: center">✗</td>
      <td style="text-align: center">✗</td>
      <td style="text-align: center">✗</td>
      <td style="text-align: center">✗</td>
      <td style="text-align: center">✗</td>
    </tr>
    <tr>
      <td>Either[E, A]</td>
      <td style="text-align: center">✔</td>
      <td style="text-align: center">✔</td>
      <td style="text-align: center">✔</td>
      <td style="text-align: center">✔</td>
      <td style="text-align: center">✔</td>
      <td style="text-align: center">✔</td>
      <td style="text-align: center">✔</td>
      <td style="text-align: center">✗</td>
      <td style="text-align: center">✗</td>
    </tr>
    <tr>
      <td>List[A]</td>
      <td style="text-align: center">✔</td>
      <td style="text-align: center">✔</td>
      <td style="text-align: center">✔</td>
      <td style="text-align: center">✔</td>
      <td style="text-align: center">✔</td>
      <td style="text-align: center">✗</td>
      <td style="text-align: center">✗</td>
      <td style="text-align: center">✔</td>
      <td style="text-align: center">✗</td>
    </tr>
    <tr>
      <td>NonEmptyList[A]</td>
      <td style="text-align: center">✔</td>
      <td style="text-align: center">✔</td>
      <td style="text-align: center">✔</td>
      <td style="text-align: center">✔</td>
      <td style="text-align: center">✗</td>
      <td style="text-align: center">✗</td>
      <td style="text-align: center">✗</td>
      <td style="text-align: center">✔</td>
      <td style="text-align: center">✔</td>
    </tr>
    <tr>
      <td>Stream[A]</td>
      <td style="text-align: center">✔</td>
      <td style="text-align: center">✔</td>
      <td style="text-align: center">✔</td>
      <td style="text-align: center">✔</td>
      <td style="text-align: center">✔</td>
      <td style="text-align: center">✗</td>
      <td style="text-align: center">✗</td>
      <td style="text-align: center">✔</td>
      <td style="text-align: center">✗</td>
    </tr>
    <tr>
      <td>Map[K, A]</td>
      <td style="text-align: center">✔</td>
      <td style="text-align: center">✔</td>
      <td style="text-align: center">✗</td>
      <td style="text-align: center">✗</td>
      <td style="text-align: center">✔</td>
      <td style="text-align: center">✗</td>
      <td style="text-align: center">✗</td>
      <td style="text-align: center">✗</td>
      <td style="text-align: center">✗</td>
    </tr>
    <tr>
      <td>Validated[E, A]</td>
      <td style="text-align: center">✔</td>
      <td style="text-align: center">✔ (<code class="language-plaintext highlighter-rouge">E: Semigroup</code>)</td>
      <td style="text-align: center">✔</td>
      <td style="text-align: center">✗</td>
      <td style="text-align: center">✗</td>
      <td style="text-align: center">✔ (<code class="language-plaintext highlighter-rouge">E: Semigroup</code>)</td>
      <td style="text-align: center">✗</td>
      <td style="text-align: center">✗</td>
      <td style="text-align: center">✗</td>
    </tr>
    <tr>
      <td>Reader[E, A]</td>
      <td style="text-align: center">✔</td>
      <td style="text-align: center">✔</td>
      <td style="text-align: center">✔</td>
      <td style="text-align: center">✔</td>
      <td style="text-align: center">✗</td>
      <td style="text-align: center">✗</td>
      <td style="text-align: center">✗</td>
      <td style="text-align: center">✗</td>
      <td style="text-align: center">✗</td>
    </tr>
    <tr>
      <td>Writer[E, A]</td>
      <td style="text-align: center">✔</td>
      <td style="text-align: center">✔ (<code class="language-plaintext highlighter-rouge">E:Monoid</code>)</td>
      <td style="text-align: center">✔</td>
      <td style="text-align: center">✔</td>
      <td style="text-align: center">✗</td>
      <td style="text-align: center">✗</td>
      <td style="text-align: center">✗</td>
      <td style="text-align: center">✔</td>
      <td style="text-align: center">✗</td>
    </tr>
  </tbody>
</table>

<h2 id="further-reading">Further reading</h2>
<ul>
  <li><a href="http://tpolecat.github.io/2015/04/29/f-bounds.html" title="Returning the &quot;Current&quot; Type in Scala">Returning the “Current” Type in Scala</a></li>
</ul>

</section></div></div></div></div><script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.3.7/js/bootstrap.min.js"></script><script src="/cats/highlight/highlight.pack.js"></script><script src="/cats/lunr/lunr.js"></script><script>
// For all code blocks, copy the language from the containing div
// to the inner code tag (where hljs expects it to be)
const langPrefix = 'language-';
document.querySelectorAll(`div[class^='${langPrefix}']`).forEach(function(div) {
  div.classList.forEach(function(cssClass) {
    if (cssClass.startsWith(langPrefix)) {
      const lang = cssClass.substring(langPrefix.length);
      div.querySelectorAll('pre code').forEach(function(code) {
        code.classList.add(lang);
      });
    }
  });
});

hljs.configure({languages:['scala','java','bash']});
hljs.initHighlightingOnLoad();
      </script><script src="/cats/js/sponsors.js"></script><script>console.info('\x57\x65\x62\x73\x69\x74\x65\x20\x62\x75\x69\x6c\x74\x20\x77\x69\x74\x68\x3a\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x5f\x5f\x20\x20\x20\x20\x5f\x5f\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x5f\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x5f\x20\x5f\x5f\x0a\x20\x20\x20\x5f\x5f\x5f\x5f\x5f\x2f\x20\x2f\x5f\x20\x20\x2f\x20\x2f\x5f\x20\x20\x20\x20\x20\x20\x5f\x5f\x5f\x5f\x20\x5f\x5f\x5f\x20\x20\x28\x5f\x29\x5f\x5f\x5f\x5f\x5f\x5f\x5f\x5f\x5f\x5f\x5f\x5f\x5f\x20\x20\x5f\x5f\x5f\x5f\x5f\x28\x5f\x29\x20\x2f\x5f\x5f\x5f\x5f\x20\x20\x5f\x5f\x5f\x5f\x5f\x0a\x20\x20\x2f\x20\x5f\x5f\x5f\x2f\x20\x5f\x5f\x20\x5c\x2f\x20\x5f\x5f\x2f\x5f\x5f\x5f\x5f\x5f\x2f\x20\x5f\x5f\x20\x60\x5f\x5f\x20\x5c\x2f\x20\x2f\x20\x5f\x5f\x5f\x2f\x20\x5f\x5f\x5f\x2f\x20\x5f\x5f\x20\x5c\x2f\x20\x5f\x5f\x5f\x2f\x20\x2f\x20\x5f\x5f\x2f\x20\x5f\x20\x5c\x2f\x20\x5f\x5f\x5f\x2f\x0a\x20\x28\x5f\x5f\x20\x20\x29\x20\x2f\x5f\x2f\x20\x2f\x20\x2f\x5f\x2f\x5f\x5f\x5f\x5f\x5f\x2f\x20\x2f\x20\x2f\x20\x2f\x20\x2f\x20\x2f\x20\x2f\x20\x2f\x5f\x5f\x2f\x20\x2f\x20\x20\x2f\x20\x2f\x5f\x2f\x20\x28\x5f\x5f\x20\x20\x29\x20\x2f\x20\x2f\x5f\x2f\x20\x20\x5f\x5f\x28\x5f\x5f\x20\x20\x29\x0a\x2f\x5f\x5f\x5f\x5f\x2f\x5f\x2e\x5f\x5f\x5f\x2f\x5c\x5f\x5f\x2f\x20\x20\x20\x20\x20\x2f\x5f\x2f\x20\x2f\x5f\x2f\x20\x2f\x5f\x2f\x5f\x2f\x5c\x5f\x5f\x5f\x2f\x5f\x2f\x20\x20\x20\x5c\x5f\x5f\x5f\x5f\x2f\x5f\x5f\x5f\x5f\x2f\x5f\x2f\x5c\x5f\x5f\x2f\x5c\x5f\x5f\x5f\x2f\x5f\x5f\x5f\x5f\x2f\x0a\x0a\x68\x74\x74\x70\x73\x3a\x2f\x2f\x34\x37\x64\x65\x67\x2e\x67\x69\x74\x68\x75\x62\x2e\x69\x6f\x2f\x73\x62\x74\x2d\x6d\x69\x63\x72\x6f\x73\x69\x74\x65\x73')</script><script>((window.gitter = {}).chat = {}).options = {
room: 'typelevel/cats'};</script><script src="https://sidecar.gitter.im/dist/sidecar.v1.js"></script><script src="/cats/js/search.js"></script><script src="/cats/js/main.js"></script></body></html>